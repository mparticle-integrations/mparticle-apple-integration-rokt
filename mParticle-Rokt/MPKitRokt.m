#import "MPKitRokt.h"
#import <Rokt_Widget/Rokt_Widget-Swift.h>

NSString * const kMPRemoteConfigKitHashesKey = @"hs";
NSString * const kMPRemoteConfigUserAttributeFilter = @"ua";
NSString * const MPKitRoktErrorDomain = @"com.mparticle.kits.rokt";
NSString * const MPKitRoktErrorMessageKey = @"mParticle-Rokt Error";
NSString * const kMPPlacementAttributesMapping = @"placementAttributesMapping";
NSString * const kMPHashedEmailUserIdentityType = @"hashedEmailUserIdentityType";
NSString * const kMPRoktEmbeddedViewClassName = @"MPRoktEmbeddedView";
NSString * const kMPEventNameSelectPlacements = @"selectPlacements";
NSInteger const kMPRoktKitCode = 181;

static __weak MPKitRokt *roktKit = nil;

@interface MPKitRokt () <MPKitProtocol>

@property (nonatomic, unsafe_unretained) BOOL started;

@end

@implementation MPKitRokt

/*
    mParticle will supply a unique kit code for you. Please contact our team
*/
+ (NSNumber *)kitCode {
    return @(kMPRoktKitCode); // Replace with the actual kit code assigned by mParticle
}

+ (void)load {
    MPKitRegister *kitRegister = [[MPKitRegister alloc] initWithName:@"Rokt" className:@"MPKitRokt"];
    [MParticle registerExtension:kitRegister];
}

- (MPKitExecStatus *)execStatus:(MPKitReturnCode)returnCode {
    return [[MPKitExecStatus alloc] initWithSDKCode:self.class.kitCode returnCode:returnCode];
}

#pragma mark - MPKitInstanceProtocol methods

#pragma mark Kit instance and lifecycle
- (MPKitExecStatus *)didFinishLaunchingWithConfiguration:(NSDictionary *)configuration {
    NSString *partnerId = configuration[@"accountId"];

    if (!partnerId) {
        return [self execStatus:MPKitReturnCodeRequirementsNotMet];
    }

    _configuration = configuration;
    roktKit = self;
    
    NSString *sdkVersion = [MParticle sharedInstance].version;
    // https://go.mparticle.com/work/SQDSDKS-7379
    NSString *kitVersion = @"8.3.2";

    // Initialize Rokt SDK here
    [MPKitRokt MPLog:[NSString stringWithFormat:@"Attempting to initialize Rokt with Kit Version: %@", kitVersion]];
    [Rokt initWithRoktTagId:partnerId mParticleSdkVersion:sdkVersion mParticleKitVersion:kitVersion onInitComplete:^(BOOL InitComplete) {
        if (InitComplete) {
            [self start];
            [MPKitRokt MPLog:@"Rokt Init Complete"];
            NSDictionary *userInfo = @{mParticleKitInstanceKey:[[self class] kitCode]};
            [[NSNotificationCenter defaultCenter] postNotificationName:@"mParticle.Rokt.Initialized"
                                                                object:nil
                                                              userInfo:userInfo];
        }
    }];
    
    return [self execStatus:MPKitReturnCodeSuccess];
}

- (void)start {
    static dispatch_once_t kitPredicate;

    dispatch_once(&kitPredicate, ^{
        self->_started = YES;

        dispatch_async(dispatch_get_main_queue(), ^{
            NSDictionary *userInfo = @{mParticleKitInstanceKey:[[self class] kitCode]};

            [[NSNotificationCenter defaultCenter] postNotificationName:mParticleKitDidBecomeActiveNotification
                                                                object:nil
                                                              userInfo:userInfo];
        });
    });
}

/// \param identifier The name that should be displayed in the widget
///
/// \param attributes A string dictionary containing the parameters that should be displayed in the widget
///
/// \param embeddedViews A dictionary of RoktEmbeddedViews with their names
///
/// \param callbacks Object that contains all possible callbacks for selectPlacements
///
/// \param filteredUser The current user when this placement was requested. Filtered for the kit as per settings in the mParticle UI
///
- (MPKitExecStatus *)executeWithIdentifier:(NSString * _Nullable)identifier
                              attributes:(NSDictionary<NSString *, NSString *> * _Nonnull)attributes
                           embeddedViews:(NSDictionary<NSString *, MPRoktEmbeddedView *> * _Nullable)embeddedViews
                                  config:(MPRoktConfig * _Nullable)mpRoktConfig
                               callbacks:(MPRoktEventCallback * _Nullable)callbacks
                            filteredUser:(FilteredMParticleUser * _Nonnull)filteredUser {
    [MPKitRokt MPLog:[NSString stringWithFormat:@"Rokt Kit recieved `executeWithIdentifier` method with the following arguments: \n identifier: %@ \n attributes: %@ \n embeddedViews: %@ \n config: %@ \n callbacks: %@ \n filteredUser identities: %@", identifier, attributes, embeddedViews, mpRoktConfig, callbacks, filteredUser.userIdentities]];
    NSDictionary<NSString *, NSString *> *finalAtt = [MPKitRokt prepareAttributes:attributes filteredUser:filteredUser performMapping:NO];
    
    // Log custom event for selectPlacements call
    [MPKitRokt logSelectPlacementEvent:finalAtt];
    
    //Convert MPRoktConfig to RoktConfig
    RoktConfig *roktConfig = [MPKitRokt convertMPRoktConfig:mpRoktConfig];
    NSDictionary<NSString *, RoktEmbeddedView *> *confirmedViews = [self confirmEmbeddedViews:embeddedViews];
    
    [Rokt executeWithViewName:identifier
                   attributes:finalAtt
                   placements:confirmedViews
                       config:roktConfig
                       onLoad:callbacks.onLoad
                     onUnLoad:callbacks.onUnLoad
 onShouldShowLoadingIndicator:callbacks.onShouldShowLoadingIndicator
 onShouldHideLoadingIndicator:callbacks.onShouldHideLoadingIndicator
         onEmbeddedSizeChange:callbacks.onEmbeddedSizeChange
    ];
    
    return [[MPKitExecStatus alloc] initWithSDKCode:[[self class] kitCode] returnCode:MPKitReturnCodeSuccess];
}

/// \param wrapperSdk The type of wrapper SDK
///
/// \param wrapperSdkVersion A string representing the wrapper SDK version
///
- (nonnull MPKitExecStatus *)setWrapperSdk:(MPWrapperSdk)wrapperSdk version:(nonnull NSString *)wrapperSdkVersion {
    RoktFrameworkType roktFrameworkType = [self mapMPWrapperSdkToRoktFrameworkType:wrapperSdk];
    [Rokt setFrameworkTypeWithFrameworkType:roktFrameworkType];

    return [[MPKitExecStatus alloc] initWithSDKCode:[[self class] kitCode] returnCode:MPKitReturnCodeSuccess];
}

- (RoktFrameworkType)mapMPWrapperSdkToRoktFrameworkType:(MPWrapperSdk)wrapperSdk {
    switch (wrapperSdk) {
        case MPWrapperSdkCordova:
            return RoktFrameworkTypeCordova;
        case MPWrapperSdkReactNative:
            return RoktFrameworkTypeReactNative;
        case MPWrapperSdkFlutter:
            return RoktFrameworkTypeFlutter;
        default:
            return RoktFrameworkTypeIOS;
    }
}

- (NSDictionary<NSString *, RoktEmbeddedView *> * _Nullable) confirmEmbeddedViews:(NSDictionary<NSString *, MPRoktEmbeddedView *> * _Nullable)embeddedViews {
    if (!embeddedViews || embeddedViews.count == 0) {
        return [NSMutableDictionary dictionary];
    }
    
    NSMutableDictionary <NSString *, RoktEmbeddedView *> *safePlacements = [NSMutableDictionary dictionary];

    for (NSString* key in embeddedViews) {
        MPRoktEmbeddedView *mpView = [embeddedViews objectForKey:key];

        BOOL isUIView = [mpView isKindOfClass:[UIView class]];
        
        if (!isUIView) {
            [MPKitRokt MPLog:[NSString stringWithFormat:@"Rokt embedded view is incorrect type. Found: %@ but required: UIView", NSStringFromClass([mpView class])]];
            continue;
        }

        Class runtimeClass = NSClassFromString(kMPRoktEmbeddedViewClassName);
        
        // Use runtime class for type checking instead of compile-time reference
        // This handles cases where the class is defined in multiple frameworks
        BOOL isProperType = runtimeClass && [mpView isKindOfClass:runtimeClass];
        
        if (isProperType) {
            // Create a new RoktEmbeddedView instance
            RoktEmbeddedView *roktView = [[RoktEmbeddedView alloc] initWithFrame:mpView.bounds];
            // Add the RoktEmbeddedView as a child view of MPRoktEmbeddedView
            [mpView addSubview:roktView];
            // Add the RoktEmbeddedView to our safe placements dictionary
            [safePlacements setObject:roktView forKey:key];
        } else {
            [MPKitRokt MPLog:[NSString stringWithFormat:@"Rokt embedded view is incorrect type. Found: %@ but required: %@", NSStringFromClass([mpView class]), kMPRoktEmbeddedViewClassName]];
        }
    }

    return safePlacements;
}

+ (NSDictionary<NSString *, NSString *> *)confirmSandboxAttribute:(NSDictionary<NSString *, NSString *> * _Nullable)attributes {
    NSMutableDictionary<NSString *, NSString *> *finalAttributes = attributes.mutableCopy;
    NSString *sandboxKey = @"sandbox";
    
    // Determine the value of the sandbox attribute based off the current environment
    NSString *sandboxValue = ([[MParticle sharedInstance] environment] == MPEnvironmentDevelopment) ? @"true" : @"false";
    
    if (finalAttributes != nil) {
        // Only set sandbox if it`s not set by the client
        if (![finalAttributes.allKeys containsObject:sandboxKey]) {
            finalAttributes[sandboxKey] = sandboxValue;
        }
    } else {
        finalAttributes = [[NSMutableDictionary alloc] initWithDictionary:@{sandboxKey: sandboxValue}];
    }
    
    [MPKitRokt MPLog:[NSString stringWithFormat:@"Sandbox value: %@", finalAttributes[sandboxKey]]];
    return finalAttributes;
}

+ (NSDictionary<NSString *, NSString *> * _Nonnull)prepareAttributes:(NSDictionary<NSString *, NSString *> * _Nonnull)attributes filteredUser:(FilteredMParticleUser * _Nullable)filteredUser performMapping:(BOOL)performMapping {
    if (filteredUser == nil && roktKit != nil) {
        filteredUser = [[[MPKitAPI alloc] init] getCurrentUserWithKit:roktKit];
    }
    NSDictionary<NSString *, NSString *> *mpAttributes = [self transformValuesToString:filteredUser.userAttributes];
    if (performMapping) {
        mpAttributes = [self mapAttributes:attributes filteredUser:filteredUser];
    }
    
    NSMutableDictionary<NSString *, NSString *> *finalAtt = [[NSMutableDictionary alloc] init];
    [finalAtt addEntriesFromDictionary:mpAttributes];
    
    // Add MPID to the attributes being passed to the Rokt SDK
    if (filteredUser.userId.stringValue != nil) {
        [finalAtt addEntriesFromDictionary:@{@"mpid": filteredUser.userId.stringValue}];
    }
    
    // Add all known user identities to the attributes being passed to the Rokt SDK
    [self addIdentityAttributes:finalAtt filteredUser:filteredUser];
    
    // Handle hashed email use case
    [self handleHashedEmail:finalAtt];
    
    // The core SDK does not set sandbox on the user, but we must pass it to Rokt if provided
    NSString *sandboxKey = @"sandbox";
    if (attributes[sandboxKey] != nil) {
        [finalAtt addEntriesFromDictionary:@{sandboxKey: attributes[sandboxKey]}];
    }
    
    [MPKitRokt MPLog:[NSString stringWithFormat:@"Attributes updated with mapped user Attributes and Identities: %@", finalAtt]];
    return [self confirmSandboxAttribute:finalAtt];
}

+ (NSDictionary<NSString *, NSString *> *)transformValuesToString:(NSDictionary<NSString *, id> * _Nullable)originalDictionary {
    __block NSMutableDictionary<NSString *, NSString *> *transformedDictionary = [[NSMutableDictionary alloc] initWithCapacity:originalDictionary.count];
    Class NSStringClass = [NSString class];
    Class NSNumberClass = [NSNumber class];
    
    [originalDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
        if ([obj isKindOfClass:NSStringClass]) {
            transformedDictionary[key] = obj;
        } else if ([obj isKindOfClass:NSNumberClass]) {
            NSNumber *numberAttribute = (NSNumber *)obj;
            
            if (numberAttribute == (void *)kCFBooleanFalse || numberAttribute == (void *)kCFBooleanTrue) {
                transformedDictionary[key] = [numberAttribute boolValue] ? @"true" : @"false";
            } else {
                transformedDictionary[key] = [numberAttribute stringValue];
            }
        } else if ([obj isKindOfClass:[NSDate class]]) {
            transformedDictionary[key] = [MPDateFormatter stringFromDateRFC3339:obj];
        } else if ([obj isKindOfClass:[NSData class]] && [(NSData *)obj length] > 0) {
            transformedDictionary[key] = [[NSString alloc] initWithData:obj encoding:NSUTF8StringEncoding];
        } else if ([obj isKindOfClass:[NSDictionary class]]) {
            transformedDictionary[key] = [obj description];
        } else if ([obj isKindOfClass:[NSMutableDictionary class]]) {
            transformedDictionary[key] = [obj description];
        } else if ([obj isKindOfClass:[NSArray class]]) {
            transformedDictionary[key] = [obj description];
        } else if ([obj isKindOfClass:[NSMutableArray class]]) {
            transformedDictionary[key] = [obj description];
        } else if ([obj isKindOfClass:[NSNull class]]) {
            transformedDictionary[key] = @"null";
        }
    }];
    
    return transformedDictionary;
}

+ (NSDictionary<NSString *, NSString *> *)mapAttributes:(NSDictionary<NSString *, NSString *> * _Nullable)attributes filteredUser:(FilteredMParticleUser * _Nonnull)filteredUser {
    NSArray<NSDictionary<NSString *, NSString *> *> *attributeMap = nil;
    
    // Get the kit configuration
    NSArray<NSDictionary *> *kitConfigs = [MParticle sharedInstance].kitContainer_PRIVATE.originalConfig.copy;
    NSDictionary *roktKitConfig;
    for (NSDictionary *kitConfig in kitConfigs) {
        if (kitConfig[@"id"] != nil && [kitConfig[@"id"] integerValue] == kMPRoktKitCode) {
            roktKitConfig = kitConfig;
        }
    }
    
    // Return nil if no Rokt Kit configuration found
    if (!roktKitConfig) {
        return attributes;
    }
    
    // Get the placement attributes map
    NSString *strAttributeMap;
    NSData *dataAttributeMap;
    // Rokt Kit is available though there may not be an attribute map
    attributeMap = @[];
    if (roktKitConfig[kMPPlacementAttributesMapping] != [NSNull null]) {
        strAttributeMap = [roktKitConfig[kMPPlacementAttributesMapping] stringByRemovingPercentEncoding];
        dataAttributeMap = [strAttributeMap dataUsingEncoding:NSUTF8StringEncoding];
    }
    
    if (dataAttributeMap != nil) {
        // Convert it to an array of dictionaries
        NSError *error = nil;
        
        @try {
            attributeMap = [NSJSONSerialization JSONObjectWithData:dataAttributeMap options:kNilOptions error:&error];
        } @catch (NSException *exception) {
        }
        
        if (attributeMap && !error) {
            NSLog(@"%@", attributeMap);
        } else {
            NSLog(@"%@", error);
        }
    }
    
    if (attributeMap) {
        NSMutableDictionary *mappedAttributes = attributes.mutableCopy;
        for (NSDictionary<NSString *, NSString *> *map in attributeMap) {
            NSString *mapFrom = map[@"map"];
            NSString *mapTo = map[@"value"];
            if (mappedAttributes[mapFrom]) {
                NSString * value = mappedAttributes[mapFrom];
                [mappedAttributes removeObjectForKey:mapFrom];
                mappedAttributes[mapTo] = value;
            }
        }
        for (NSString *key in mappedAttributes) {
            if (![key isEqual:@"sandbox"]) {
                [[MParticle sharedInstance].identity.currentUser setUserAttribute:key value:mappedAttributes[key]];
            }
        }
        
        // Add userAttributes to the attributes sent to Rokt
        for (NSString *uaKey in filteredUser.userAttributes) {
            if (![mappedAttributes.allKeys containsObject:uaKey]) {
                mappedAttributes[uaKey] = filteredUser.userAttributes[uaKey];
            }
        }
        
        return [self transformValuesToString:mappedAttributes];
    } else {
        return attributes;
    }
}

+ (void)addIdentityAttributes:(NSMutableDictionary<NSString *, NSString *> * _Nullable)attributes filteredUser:(FilteredMParticleUser * _Nonnull)filteredUser {
    NSMutableDictionary<NSString *, NSString *> *identityAttributes = [[NSMutableDictionary alloc] init];
    for (NSNumber *identityNumberKey in filteredUser.userIdentities) {
        NSString *identityStringKey = [MPKitRokt stringForIdentityType:identityNumberKey.unsignedIntegerValue];
        [identityAttributes setObject:filteredUser.userIdentities[identityNumberKey] forKey:identityStringKey];
    }
    
    if (attributes != nil) {
        [attributes addEntriesFromDictionary:identityAttributes];
    } else {
        attributes = identityAttributes;
    }
}

+ (void)handleHashedEmail:(NSMutableDictionary<NSString *, NSString *> * _Nullable)attributes {
    NSString *emailKey = [MPKitRokt stringForIdentityType:MPIdentityEmail];
    NSString *hashedEmailValue = attributes[@"emailsha256"];
    
    // Remove email if hashed value set
    if (hashedEmailValue != nil) {
        [attributes removeObjectForKey:emailKey];
    }
}

+ (RoktConfig *)convertMPRoktConfig:(MPRoktConfig *)mpRoktConfig {
    if (mpRoktConfig != nil) {
        Builder *builder = [[Builder alloc] init];

        if (mpRoktConfig.cacheDuration != nil) {
            CacheConfig *cacheConfig = [[CacheConfig alloc] initWithCacheDuration:mpRoktConfig.cacheDuration.doubleValue cacheAttributes:mpRoktConfig.cacheAttributes];
            builder = [builder cacheConfig:cacheConfig];
        }
        
        builder = [builder colorMode:(ColorMode)mpRoktConfig.colorMode];
        
        RoktConfig *config = [builder build];
        
        return config;
    }
    
    return nil;
}

+ (NSString *)stringForIdentityType:(MPIdentity)identityType {
    NSNumber *hashedEmailIdentity = [MPKitRokt getRoktHashedEmailUserIdentityType];
    
    if (hashedEmailIdentity && hashedEmailIdentity.unsignedIntValue == identityType) {
        return @"emailsha256";
    }
    
    NSDictionary<NSNumber *, NSString *> *identityStrings = @{@(MPIdentityCustomerId): @"customerid",
                                                             @(MPIdentityEmail): @"email",
                                                             @(MPIdentityFacebook): @"facebook",
                                                             @(MPIdentityFacebookCustomAudienceId): @"facebookcustomaudienceid",
                                                             @(MPIdentityGoogle): @"google",
                                                             @(MPIdentityMicrosoft): @"microsoft",
                                                             @(MPIdentityOther): @"other",
                                                             @(MPIdentityTwitter): @"twitter",
                                                             @(MPIdentityYahoo): @"yahoo",
                                                             @(MPIdentityOther2): @"other2",
                                                             @(MPIdentityOther3): @"other3",
                                                             @(MPIdentityOther4): @"other4",
                                                             @(MPIdentityOther5): @"other5",
                                                             @(MPIdentityOther6): @"other6",
                                                             @(MPIdentityOther7): @"other7",
                                                             @(MPIdentityOther8): @"other8",
                                                             @(MPIdentityOther9): @"other9",
                                                             @(MPIdentityOther10): @"other10",
                                                             @(MPIdentityMobileNumber): @"mobile_number",
                                                             @(MPIdentityPhoneNumber2): @"phone_number_2",
                                                             @(MPIdentityPhoneNumber3): @"phone_number_3",
                                                             @(MPIdentityIOSAdvertiserId): @"ios_idfa",
                                                             @(MPIdentityIOSVendorId): @"ios_idfv",
                                                             @(MPIdentityPushToken): @"push_token",
                                                             @(MPIdentityDeviceApplicationStamp): @"device_application_stamp"};

    return identityStrings[@(identityType)];
}

+ (NSNumber *)identityTypeForString:(NSString *)identityString {
    if (identityString == nil) {
        return nil;
    }
    NSDictionary<NSString *, NSNumber *> *identityNumbers = @{@"customerid": @(MPIdentityCustomerId),
                                                             @"email": @(MPIdentityEmail),
                                                             @"facebook": @(MPIdentityFacebook),
                                                             @"facebookcustomaudienceid": @(MPIdentityFacebookCustomAudienceId),
                                                             @"google": @(MPIdentityGoogle),
                                                             @"microsoft": @(MPIdentityMicrosoft),
                                                             @"other": @(MPIdentityOther),
                                                             @"twitter": @(MPIdentityTwitter),
                                                             @"yahoo": @(MPIdentityYahoo),
                                                             @"other2": @(MPIdentityOther2),
                                                             @"other3": @(MPIdentityOther3),
                                                             @"other4": @(MPIdentityOther4),
                                                             @"other5": @(MPIdentityOther5),
                                                             @"other6": @(MPIdentityOther6),
                                                             @"other7": @(MPIdentityOther7),
                                                             @"other8": @(MPIdentityOther8),
                                                             @"other9": @(MPIdentityOther9),
                                                             @"other10": @(MPIdentityOther10),
                                                             @"mobile_number": @(MPIdentityMobileNumber),
                                                             @"phone_number_2": @(MPIdentityPhoneNumber2),
                                                             @"phone_number_3": @(MPIdentityPhoneNumber3),
                                                             @"ios_idfa": @(MPIdentityIOSAdvertiserId),
                                                             @"ios_idfv": @(MPIdentityIOSVendorId),
                                                             @"push_token": @(MPIdentityPushToken),
                                                             @"device_application_stamp": @(MPIdentityDeviceApplicationStamp)};
    
    return identityNumbers[identityString];
}

+ (NSDictionary *)getKitConfig {
    // Get the kit configuration
    NSArray<NSDictionary *> *kitConfigs = [MParticle sharedInstance].kitContainer_PRIVATE.originalConfig.copy;
    NSDictionary *roktKitConfig;
    for (NSDictionary *kitConfig in kitConfigs) {
        if (kitConfig[@"id"] != nil && [kitConfig[@"id"] integerValue] == kMPRoktKitCode) {
            roktKitConfig = kitConfig;
        }
    }
    
    return roktKitConfig;
}

+ (NSNumber *)getRoktHashedEmailUserIdentityType {
    NSDictionary *roktKitConfig = [MPKitRokt getKitConfig];
    
    // Get the string representing which identity to use and convert it to the key (NSNumber)
    NSString *hashedIdentityTypeString = roktKitConfig[kMPHashedEmailUserIdentityType];
    NSNumber *hashedIdentityTypeNumber = [MPKitRokt identityTypeForString:hashedIdentityTypeString.lowercaseString];
    
    return hashedIdentityTypeNumber;
}

- (MPKitExecStatus *)purchaseFinalized:(NSString *)placementId catalogItemId:(NSString *)catalogItemId success:(NSNumber *)success {
    if (placementId != nil && catalogItemId != nil && success != nil) {
        if (@available(iOS 15.0, *)) {
            [Rokt purchaseFinalizedWithPlacementId:placementId catalogItemId:catalogItemId success:success.boolValue];
            return [[MPKitExecStatus alloc] initWithSDKCode:[[self class] kitCode] returnCode:MPKitReturnCodeSuccess];
        }
        return [[MPKitExecStatus alloc] initWithSDKCode:[[self class] kitCode] returnCode:MPKitReturnCodeUnavailable];
    }
    return [[MPKitExecStatus alloc] initWithSDKCode:[[self class] kitCode] returnCode:MPKitReturnCodeFail];
}

- (MPKitExecStatus *)events:(NSString *)identifier onEvent:(void (^)(MPRoktEvent * _Nonnull))onEvent {
    [Rokt eventsWithViewName:identifier onEvent:^(RoktEvent * _Nonnull event) {
        MPRoktEvent *mpEvent = [MPKitRokt mapEvent:event];
        if (mpEvent) {
            onEvent(mpEvent);
        }
    }];
    return [[MPKitExecStatus alloc] initWithSDKCode:[[self class] kitCode] returnCode:MPKitReturnCodeSuccess];
}

- (MPKitExecStatus *)close {
    [Rokt close];
    return [[MPKitExecStatus alloc] initWithSDKCode:[[self class] kitCode] returnCode:MPKitReturnCodeSuccess];
}

#pragma mark - User attributes and identities

- (MPKitExecStatus *)setUserIdentity:(NSString *)identityString identityType:(MPUserIdentity)identityType {
    MPKitExecStatus *execStatus = nil;
    
    if (identityType == MPUserIdentityEmail) {
        // Set user email in Rokt SDK
        // [Rokt setUserEmail:identityString];
        execStatus = [[MPKitExecStatus alloc] initWithSDKCode:[[self class] kitCode] returnCode:MPKitReturnCodeSuccess];
    } else if (identityType == MPUserIdentityCustomerId) {
        // Set user ID in Rokt SDK
        // [Rokt setUserId:identityString];
        execStatus = [[MPKitExecStatus alloc] initWithSDKCode:[[self class] kitCode] returnCode:MPKitReturnCodeSuccess];
    } else {
        execStatus = [[MPKitExecStatus alloc] initWithSDKCode:[[self class] kitCode] returnCode:MPKitReturnCodeUnavailable];
    }
    
    return execStatus;
}

#pragma mark Application
/*
    Implement this method if your SDK handles a user interacting with a remote notification action
*/
 - (MPKitExecStatus *)handleActionWithIdentifier:(NSString *)identifier forRemoteNotification:(NSDictionary *)userInfo {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
 }

/*
    Implement this method if your SDK receives and handles remote notifications
*/
 - (MPKitExecStatus *)receivedUserNotification:(NSDictionary *)userInfo {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
 }

/*
    Implement this method if your SDK registers the device token for remote notifications
*/
 - (MPKitExecStatus *)setDeviceToken:(NSData *)deviceToken {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
 }

/*
    Implement this method if your SDK handles continueUserActivity method from the App Delegate
*/
 - (nonnull MPKitExecStatus *)continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(void(^ _Nonnull)(NSArray * _Nullable restorableObjects))restorationHandler {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
 }

/*
    Implement this method if your SDK handles the iOS 9 and above App Delegate method to open URL with options
*/
 - (nonnull MPKitExecStatus *)openURL:(nonnull NSURL *)url options:(nullable NSDictionary<NSString *, id> *)options {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
 }

/*
    Implement this method if your SDK handles the iOS 8 and below App Delegate method open URL
*/
 - (nonnull MPKitExecStatus *)openURL:(nonnull NSURL *)url sourceApplication:(nullable NSString *)sourceApplication annotation:(nullable id)annotation {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
 }

#pragma mark User attributes
/*
    Implement this method if your SDK allows for incrementing numeric user attributes.
*/
- (MPKitExecStatus *)onIncrementUserAttribute:(FilteredMParticleUser *)user {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
}

/*
    Implement this method if your SDK resets user attributes.
*/
- (MPKitExecStatus *)onRemoveUserAttribute:(FilteredMParticleUser *)user {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
}

/*
    Implement this method if your SDK sets user attributes.
*/
- (MPKitExecStatus *)onSetUserAttribute:(FilteredMParticleUser *)user {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
}

/*
    Implement this method if your SDK supports setting value-less attributes
*/
- (MPKitExecStatus *)onSetUserTag:(FilteredMParticleUser *)user {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
}

#pragma mark Identity
/*
    Implement this method if your SDK should be notified any time the mParticle ID (MPID) changes. This will occur on initial install of the app, and potentially after a login or logout.
*/
- (MPKitExecStatus *)onIdentifyComplete:(FilteredMParticleUser *)user request:(FilteredMPIdentityApiRequest *)request {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
}

/*
    Implement this method if your SDK should be notified when the user logs in
*/
- (MPKitExecStatus *)onLoginComplete:(FilteredMParticleUser *)user request:(FilteredMPIdentityApiRequest *)request {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
}

/*
    Implement this method if your SDK should be notified when the user logs out
*/
- (MPKitExecStatus *)onLogoutComplete:(FilteredMParticleUser *)user request:(FilteredMPIdentityApiRequest *)request {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
}

/*
    Implement this method if your SDK should be notified when user identities change
*/
- (MPKitExecStatus *)onModifyComplete:(FilteredMParticleUser *)user request:(FilteredMPIdentityApiRequest *)request {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
}

#pragma mark Events
/*
    Implement this method if your SDK wants to log any kind of events.
    Please see MPBaseEvent.h
*/
- (nonnull MPKitExecStatus *)logBaseEvent:(nonnull MPBaseEvent *)event {
    if ([event isKindOfClass:[MPEvent class]]) {
        return [self routeEvent:(MPEvent *)event];
    } else if ([event isKindOfClass:[MPCommerceEvent class]]) {
        return [self routeCommerceEvent:(MPCommerceEvent *)event];
    } else {
        return [self execStatus:MPKitReturnCodeUnavailable];
    }
}
/*
    Implement this method if your SDK logs user events.
    This requires logBaseEvent to be implemented as well.
    Please see MPEvent.h
*/
 - (MPKitExecStatus *)routeEvent:(MPEvent *)event {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
 }
/*
    Implement this method if your SDK logs screen events
    Please see MPEvent.h
*/
 - (MPKitExecStatus *)logScreen:(MPEvent *)event {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
 }

#pragma mark e-Commerce
/*
    Implement this method if your SDK supports commerce events.
    This requires logBaseEvent to be implemented as well.
    If your SDK does support commerce event, but does not support all commerce event actions available in the mParticle SDK,
    expand the received commerce event into regular events and log them accordingly (see sample code below)
    Please see MPCommerceEvent.h > MPCommerceEventAction for complete list
*/
 - (MPKitExecStatus *)routeCommerceEvent:(MPCommerceEvent *)commerceEvent {
     MPKitExecStatus *execStatus = [self execStatus:MPKitReturnCodeSuccess];

     // In this example, this SDK only supports the 'Purchase' commerce event action
     if (commerceEvent.action == MPCommerceEventActionPurchase) {
             /* Your code goes here. */

             [execStatus incrementForwardCount];
     } else { // Other commerce events are expanded and logged as regular events
         NSArray *expandedInstructions = [commerceEvent expandedInstructions];

         for (MPCommerceEventInstruction *commerceEventInstruction in expandedInstructions) {
             [self routeEvent:commerceEventInstruction.event];
             [execStatus incrementForwardCount];
         }
     }

     return execStatus;
 }

#pragma mark Assorted
/*
    Implement this method if your SDK implements an opt out mechanism for users.
*/
 - (MPKitExecStatus *)setOptOut:(BOOL)optOut {
     /*  Your code goes here.
         If the execution is not successful, please use a code other than MPKitReturnCodeSuccess for the execution status.
         Please see MPKitExecStatus.h for all exec status codes
      */

     return [self execStatus:MPKitReturnCodeSuccess];
 }

+ (void)MPLog:(NSString *)string {
    NSString *msg = [NSString stringWithFormat:@"%@%@", @"MPRokt -> ", string];
    if ([[MParticle sharedInstance] environment] == MPEnvironmentDevelopment) {
        NSLog(@"%@", msg);
    }
}

+ (void)logSelectPlacementEvent:(NSDictionary<NSString *, NSString *> * _Nonnull)attributes {
    MPEvent *event = [[MPEvent alloc] initWithName:kMPEventNameSelectPlacements type:MPEventTypeOther];
    event.customAttributes = attributes;
    [[MParticle sharedInstance] logEvent:event];
    [MPKitRokt MPLog:[NSString stringWithFormat:@"Logged selectplacements custom event with attributes: %@", attributes]];
}


+ (MPRoktEvent * _Nullable)mapEvent:(RoktEvent *)event {
    if (!event) {
        return nil;
    }
    
    // Check for RoktEvent.InitComplete
    if ([event isKindOfClass:[InitComplete class]]) {
        InitComplete *initComplete = (InitComplete *)event;
        return [[MPRoktInitComplete alloc] initWithSuccess:initComplete.success];
    }
    
    // Check for RoktEvent.ShowLoadingIndicator
    if ([event isKindOfClass:[ShowLoadingIndicator class]]) {
        return [[MPRoktShowLoadingIndicator alloc] init];
    }
    
    // Check for RoktEvent.HideLoadingIndicator
    if ([event isKindOfClass:[HideLoadingIndicator class]]) {
        return [[MPRoktHideLoadingIndicator alloc] init];

    }
    
    // Check for RoktEvent.PlacementInteractive
    if ([event isKindOfClass:[PlacementInteractive class]]) {
        PlacementInteractive *placementInteractive = (PlacementInteractive *)event;
        return [[MPRoktPlacementInteractive alloc] initWithPlacementId:placementInteractive.placementId];
    }
    
    // Check for RoktEvent.PlacementReady
    if ([event isKindOfClass:[PlacementReady class]]) {
        PlacementReady *placementReady = (PlacementReady *)event;
        return [[MPRoktPlacementReady alloc] initWithPlacementId:placementReady.placementId];
    }
    
    // Check for RoktEvent.OfferEngagement
    if ([event isKindOfClass:[OfferEngagement class]]) {
        OfferEngagement *offerEngagement = (OfferEngagement *)event;
        return [[MPRoktOfferEngagement alloc] initWithPlacementId:offerEngagement.placementId];
    }
    
    // Check for RoktEvent.OpenUrl
    if ([event isKindOfClass:[OpenUrl class]]) {
        OpenUrl *openUrl = (OpenUrl *)event;
        return [[MPRoktOpenUrl alloc] initWithPlacementId:openUrl.placementId url:openUrl.url];
    }
    
    // Check for RoktEvent.PositiveEngagement
    if ([event isKindOfClass:[PositiveEngagement class]]) {
        PositiveEngagement *positiveEngagement = (PositiveEngagement *)event;
        return [[MPRoktPositiveEngagement alloc] initWithPlacementId:positiveEngagement.placementId];
    }
    
    // Check for RoktEvent.PlacementClosed
    if ([event isKindOfClass:[PlacementClosed class]]) {
        PlacementClosed *placementClosed = (PlacementClosed *)event;
        return [[MPRoktPlacementClosed alloc] initWithPlacementId:placementClosed.placementId];
    }
    
    // Check for RoktEvent.PlacementCompleted
    if ([event isKindOfClass:[PlacementCompleted class]]) {
        PlacementCompleted *placementCompleted = (PlacementCompleted *)event;
        return [[MPRoktPlacementCompleted alloc] initWithPlacementId:placementCompleted.placementId];
    }
    
    // Check for RoktEvent.PlacementFailure
    if ([event isKindOfClass:[PlacementFailure class]]) {
        PlacementFailure *placementFailure = (PlacementFailure *)event;
        return [[MPRoktPlacementFailure alloc] initWithPlacementId:placementFailure.placementId];
    }
    
    // Check for RoktEvent.FirstPositiveEngagement
    if ([event isKindOfClass:[FirstPositiveEngagement class]]) {
        FirstPositiveEngagement *firstPositiveEngagement = (FirstPositiveEngagement *)event;
        return [[MPRoktFirstPositiveEngagement alloc] initWithPlacementId:firstPositiveEngagement.placementId];
    }
    
    // Check for RoktEvent.CartItemInstantPurchase
    if ([event isKindOfClass:[CartItemInstantPurchase class]]) {
        CartItemInstantPurchase *cartItemInstantPurchase = (CartItemInstantPurchase *)event;
        
        // Handle nil coalescing for name field
        NSString *name = cartItemInstantPurchase.name ?: @"";
        
        return [[MPRoktCartItemInstantPurchase alloc] initWithPlacementId:cartItemInstantPurchase.placementId
                                                                     name:name
                                                               cartItemId:cartItemInstantPurchase.cartItemId
                                                            catalogItemId:cartItemInstantPurchase.catalogItemId
                                                                 currency:cartItemInstantPurchase.currency
                                                              description:cartItemInstantPurchase.description
                                                          linkedProductId:cartItemInstantPurchase.linkedProductId
                                                             providerData:cartItemInstantPurchase.providerData
                                                                 quantity:cartItemInstantPurchase.quantity
                                                               totalPrice:cartItemInstantPurchase.totalPrice
                                                                unitPrice:cartItemInstantPurchase.unitPrice];
    }
    
    // Default case - return nil if no matching event type found
    return nil;
}

@end
